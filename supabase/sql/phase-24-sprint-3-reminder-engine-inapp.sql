begin;

-- =====================================================
-- PHASE 24: Sprint 03 - Motor de Lembretes In-App
-- =====================================================
-- Objetivo:
-- 1) Registrar entregas de lembrete com idempotência por paciente/tipo/dia/canal.
-- 2) Processar geração de lembretes in-app com base em preferências salvas.
-- 3) Instrumentar evento reminder_sent no contrato de activity_log.

create table if not exists public.reminder_delivery_log (
  id bigint generated by default as identity primary key,
  patient_id uuid not null references public.user_profiles(id) on delete cascade,
  reminder_type text not null check (reminder_type in ('daily_log_reminder', 'measurement_reminder')),
  delivery_channel text not null default 'in_app' check (delivery_channel in ('in_app')),
  reminder_date date not null,
  reminder_time time not null,
  status text not null default 'sent' check (status in ('sent', 'skipped', 'failed')),
  notification_id bigint null references public.notifications(id) on delete set null,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create unique index if not exists uq_reminder_delivery_daily
  on public.reminder_delivery_log(patient_id, reminder_type, reminder_date, delivery_channel);

create index if not exists idx_reminder_delivery_patient_created
  on public.reminder_delivery_log(patient_id, created_at desc);

alter table public.reminder_delivery_log enable row level security;

drop policy if exists reminder_delivery_log_select_own on public.reminder_delivery_log;
create policy reminder_delivery_log_select_own
  on public.reminder_delivery_log
  for select
  using (patient_id = auth.uid());

drop policy if exists reminder_delivery_log_insert_service_role on public.reminder_delivery_log;
create policy reminder_delivery_log_insert_service_role
  on public.reminder_delivery_log
  for insert
  with check (true);

drop policy if exists reminder_delivery_log_select_nutritionist on public.reminder_delivery_log;
create policy reminder_delivery_log_select_nutritionist
  on public.reminder_delivery_log
  for select
  using (
    exists (
      select 1
      from public.user_profiles up
      where up.id = reminder_delivery_log.patient_id
        and up.nutritionist_id = auth.uid()
    )
  );

create or replace function public.process_patient_reminders(
  p_patient_id uuid default auth.uid()
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_patient_id uuid;
  v_now timestamptz := now();
  v_today date := (now())::date;
  v_now_time time := (now())::time;
  v_prefs record;
  v_daily_due boolean := false;
  v_measurement_due boolean := false;
  v_has_meal_today boolean := false;
  v_last_measurement_date date;
  v_notification_id bigint;
  v_daily_sent int := 0;
  v_measurement_sent int := 0;
begin
  v_patient_id := coalesce(p_patient_id, auth.uid());
  if v_patient_id is null then
    return jsonb_build_object('processed', false, 'reason', 'missing_patient_id');
  end if;

  select *
    into v_prefs
  from public.patient_reminder_preferences
  where patient_id = v_patient_id;

  if not found then
    insert into public.patient_reminder_preferences (patient_id)
    values (v_patient_id)
    on conflict (patient_id) do nothing;

    select *
      into v_prefs
    from public.patient_reminder_preferences
    where patient_id = v_patient_id;
  end if;

  if v_prefs is null then
    return jsonb_build_object('processed', false, 'reason', 'missing_preferences');
  end if;

  select exists (
    select 1
    from public.meals m
    where m.patient_id = v_patient_id
      and m.meal_date = v_today
      and m.deleted_at is null
  )
  into v_has_meal_today;

  select max(gr.record_date)
    into v_last_measurement_date
  from public.growth_records gr
  where gr.patient_id = v_patient_id;

  if coalesce(v_prefs.channel_in_app, true) then
    if coalesce(v_prefs.daily_log_enabled, true)
      and v_now_time >= coalesce(v_prefs.daily_log_time, '20:00'::time)
      and not v_has_meal_today then
      v_daily_due := true;
    end if;

    if coalesce(v_prefs.measurement_enabled, true)
      and v_now_time >= coalesce(v_prefs.measurement_time, '09:00'::time)
      and (v_last_measurement_date is null or v_last_measurement_date <= (v_today - interval '7 days')::date) then
      v_measurement_due := true;
    end if;
  end if;

  if v_daily_due then
    if not exists (
      select 1
      from public.reminder_delivery_log r
      where r.patient_id = v_patient_id
        and r.reminder_type = 'daily_log_reminder'
        and r.delivery_channel = 'in_app'
        and r.reminder_date = v_today
    ) then
      insert into public.notifications(user_id, type, content, is_read)
      values (
        v_patient_id,
        'daily_log_reminder',
        jsonb_build_object(
          'title', 'Lembrete Diário',
          'message', 'Não se esqueça de registrar suas refeições hoje!',
          'source_module', 'reminder_engine'
        ),
        false
      )
      returning id into v_notification_id;

      insert into public.reminder_delivery_log(
        patient_id, reminder_type, delivery_channel, reminder_date, reminder_time, status, notification_id
      )
      values (
        v_patient_id, 'daily_log_reminder', 'in_app', v_today, coalesce(v_prefs.daily_log_time, '20:00'::time), 'sent', v_notification_id
      );

      begin
        perform public.log_activity_event(
          'reminder_sent',
          1,
          'reminder_engine',
          v_patient_id,
          null,
          jsonb_build_object(
            'reminder_type', 'daily_log_reminder',
            'delivery_channel', 'in_app',
            'notification_id', v_notification_id
          )
        );
      exception when undefined_function then
        null;
      end;

      v_daily_sent := 1;
    end if;
  end if;

  if v_measurement_due then
    if not exists (
      select 1
      from public.reminder_delivery_log r
      where r.patient_id = v_patient_id
        and r.reminder_type = 'measurement_reminder'
        and r.delivery_channel = 'in_app'
        and r.reminder_date = v_today
    ) then
      insert into public.notifications(user_id, type, content, is_read)
      values (
        v_patient_id,
        'measurement_reminder',
        jsonb_build_object(
          'title', 'Atualizar Medidas',
          'message', 'Atualize suas medidas para manter seu plano calibrado.',
          'source_module', 'reminder_engine'
        ),
        false
      )
      returning id into v_notification_id;

      insert into public.reminder_delivery_log(
        patient_id, reminder_type, delivery_channel, reminder_date, reminder_time, status, notification_id
      )
      values (
        v_patient_id, 'measurement_reminder', 'in_app', v_today, coalesce(v_prefs.measurement_time, '09:00'::time), 'sent', v_notification_id
      );

      begin
        perform public.log_activity_event(
          'reminder_sent',
          1,
          'reminder_engine',
          v_patient_id,
          null,
          jsonb_build_object(
            'reminder_type', 'measurement_reminder',
            'delivery_channel', 'in_app',
            'notification_id', v_notification_id
          )
        );
      exception when undefined_function then
        null;
      end;

      v_measurement_sent := 1;
    end if;
  end if;

  return jsonb_build_object(
    'processed', true,
    'patient_id', v_patient_id,
    'daily_sent', v_daily_sent,
    'measurement_sent', v_measurement_sent,
    'timestamp', v_now
  );
end;
$$;

grant execute on function public.process_patient_reminders(uuid) to authenticated;

commit;
