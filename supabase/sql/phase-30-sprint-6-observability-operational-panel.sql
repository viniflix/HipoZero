begin;

-- Sprint 06 - Etapa 5
-- Observabilidade operacional: erro + latencia por modulo.

create table if not exists public.operational_observability_log (
  id bigint generated by default as identity primary key,
  nutritionist_id uuid null references public.user_profiles(id) on delete set null,
  patient_id uuid null references public.user_profiles(id) on delete set null,
  module text not null check (module in ('feed', 'meal_plan', 'food_diary', 'agenda', 'system')),
  operation text not null,
  event_type text not null check (event_type in ('success', 'error')),
  latency_ms int not null default 0 check (latency_ms >= 0),
  error_message text null,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

create index if not exists operational_observability_log_nutritionist_created_idx
  on public.operational_observability_log (nutritionist_id, created_at desc);

create index if not exists operational_observability_log_module_created_idx
  on public.operational_observability_log (module, created_at desc);

create index if not exists operational_observability_log_event_created_idx
  on public.operational_observability_log (event_type, created_at desc);

alter table public.operational_observability_log enable row level security;

drop policy if exists operational_observability_select_scoped on public.operational_observability_log;
create policy operational_observability_select_scoped
  on public.operational_observability_log
  for select
  to authenticated
  using (
    nutritionist_id = auth.uid()
    or exists (
      select 1
      from public.user_profiles up
      where up.id = auth.uid()
        and up.role = 'super_admin'
    )
  );

drop policy if exists operational_observability_insert_authenticated on public.operational_observability_log;
create policy operational_observability_insert_authenticated
  on public.operational_observability_log
  for insert
  to authenticated
  with check (true);

create or replace function public.log_operational_event(
  p_module text,
  p_operation text,
  p_event_type text default 'success',
  p_latency_ms int default 0,
  p_nutritionist_id uuid default null,
  p_patient_id uuid default null,
  p_error_message text default null,
  p_metadata jsonb default '{}'::jsonb
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_event_id bigint;
begin
  if p_module is null or trim(p_module) = '' then
    p_module := 'system';
  end if;
  if p_operation is null or trim(p_operation) = '' then
    p_operation := 'unknown_operation';
  end if;
  if p_event_type not in ('success', 'error') then
    p_event_type := 'error';
  end if;

  insert into public.operational_observability_log (
    nutritionist_id,
    patient_id,
    module,
    operation,
    event_type,
    latency_ms,
    error_message,
    metadata
  )
  values (
    p_nutritionist_id,
    p_patient_id,
    p_module,
    p_operation,
    p_event_type,
    greatest(coalesce(p_latency_ms, 0), 0),
    p_error_message,
    coalesce(p_metadata, '{}'::jsonb)
  )
  returning id into v_event_id;

  return v_event_id;
end;
$$;

create or replace function public.get_operational_health_summary(
  p_nutritionist_id uuid default auth.uid(),
  p_window_hours int default 24
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_now timestamptz := now();
  v_since timestamptz;
  v_total int := 0;
  v_errors int := 0;
  v_error_rate numeric := 0;
  v_avg_latency numeric := 0;
  v_module_stats jsonb := '[]'::jsonb;
begin
  v_since := v_now - make_interval(hours => greatest(1, least(coalesce(p_window_hours, 24), 168)));

  with filtered as (
    select *
    from public.operational_observability_log l
    where l.created_at >= v_since
      and (p_nutritionist_id is null or l.nutritionist_id = p_nutritionist_id)
  )
  select
    count(*)::int,
    count(*) filter (where event_type = 'error')::int,
    coalesce(avg(latency_ms), 0)
  into v_total, v_errors, v_avg_latency
  from filtered;

  v_error_rate := case when v_total > 0 then round((v_errors::numeric / v_total::numeric) * 100, 2) else 0 end;

  with filtered as (
    select *
    from public.operational_observability_log l
    where l.created_at >= v_since
      and (p_nutritionist_id is null or l.nutritionist_id = p_nutritionist_id)
  ),
  by_module as (
    select
      module,
      count(*)::int as total_events,
      count(*) filter (where event_type = 'error')::int as error_events,
      round(coalesce(avg(latency_ms), 0), 2) as avg_latency_ms
    from filtered
    group by module
  )
  select coalesce(
    jsonb_agg(
      jsonb_build_object(
        'module', module,
        'total_events', total_events,
        'error_events', error_events,
        'avg_latency_ms', avg_latency_ms
      )
      order by module
    ),
    '[]'::jsonb
  )
  into v_module_stats
  from by_module;

  return jsonb_build_object(
    'window_hours', greatest(1, least(coalesce(p_window_hours, 24), 168)),
    'since', v_since,
    'until', v_now,
    'total_events', v_total,
    'error_events', v_errors,
    'error_rate', v_error_rate,
    'avg_latency_ms', round(v_avg_latency, 2),
    'module_stats', v_module_stats
  );
end;
$$;

grant execute on function public.log_operational_event(text, text, text, int, uuid, uuid, text, jsonb) to authenticated;
grant execute on function public.get_operational_health_summary(uuid, int) to authenticated;

commit;
