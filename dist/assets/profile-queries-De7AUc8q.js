import{s as c}from"./index-CzP_nI2M.js";async function l(e,s){const{data:t,error:i}=await c.from("user_profiles").select("preferences, clinic_settings").eq("id",e).single();if(i)throw console.error("Error fetching current settings:",i),i;const n={...t.clinic_settings||t.preferences?.clinic_settings||{},...s},o={},{error:u}=await c.from("user_profiles").update({clinic_settings:n}).eq("id",e);if(u){const f=t.preferences||{};o.preferences={...f,clinic_settings:n}}else o.clinic_settings=n;const{data:p,error:a}=await c.from("user_profiles").update(o).eq("id",e).select().single();if(a)throw console.error("Error updating clinic settings:",a),a;return p}async function g(e){const{data:s,error:t}=await c.from("user_profiles").select("clinic_settings, preferences").eq("id",e).single();if(t)throw console.error("Error fetching clinic settings:",t),t;return s.clinic_settings||s.preferences?.clinic_settings||{}}async function _(e){return(await g(e)).recurring_expenses||[]}async function w(e,s){const i=(await g(e)).recurring_expenses||[];let r;if(s.id)r=i.map(n=>n.id===s.id?{...s}:n);else{const n={id:Date.now().toString(),...s};r=[...i,n]}return await l(e,{recurring_expenses:r}),r}async function x(e,s){const r=((await g(e)).recurring_expenses||[]).filter(n=>n.id!==s);return await l(e,{recurring_expenses:r}),r}export{_ as a,x as d,g,w as s,l as u};
